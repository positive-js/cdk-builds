{"version":3,"file":"focus-monitor.js","sourceRoot":"","sources":["../../../../../../src/cdk/a11y/focus-monitor/focus-monitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform, supportsPassiveEventListeners } from '@ptsecurity/cdk/platform';\nimport {\n    Directive,\n    ElementRef,\n    EventEmitter,\n    Injectable,\n    NgZone,\n    OnDestroy,\n    Optional,\n    Output,\n    Renderer2,\n    SkipSelf,\n} from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { of as observableOf } from 'rxjs/observable/of';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nexport const TOUCH_BUFFER_MS = 650;\n\n\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program' | null;\n\n\ntype MonitoredElementInfo = {\n    unlisten: Function,\n    checkChildren: boolean,\n    subject: Subject<FocusOrigin>\n};\n\n\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\n@Injectable()\nexport class FocusMonitor implements OnDestroy {\n    /** The focus origin that the next focus event is a result of. */\n    private _origin: FocusOrigin = null;\n\n    /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */\n    private _lastFocusOrigin: FocusOrigin;\n\n    /** Whether the window has just been focused. */\n    private _windowFocused = false;\n\n    /** The target of the last touch event. */\n    private _lastTouchTarget: EventTarget | null;\n\n    /** The timeout id of the touch timeout, used to cancel timeout later. */\n    private _touchTimeoutId: number;\n\n    /** The timeout id of the window focus timeout. */\n    private _windowFocusTimeoutId: number;\n\n    /** The timeout id of the origin clearing timeout. */\n    private _originTimeoutId: number;\n\n    /** Map of elements being monitored to their info. */\n    private _elementInfo = new Map<HTMLElement, MonitoredElementInfo>();\n\n    /** A map of global objects to lists of current listeners. */\n    private _unregisterGlobalListeners = () => {};\n\n    /** The number of elements currently being monitored. */\n    private _monitoredElementCount = 0;\n\n    constructor(private _ngZone: NgZone, private _platform: Platform) {}\n\n    /**\n     * @docs-private\n     * @deprecated renderer param no longer needed.\n     * @deletion-target 6.0.0\n     */\n    monitor(element: HTMLElement, renderer: Renderer2, checkChildren: boolean): Observable<FocusOrigin>;\n    /**\n     * Monitors focus on an element and applies appropriate CSS classes.\n     * @param element The element to monitor\n     * @param checkChildren Whether to count the element as focused when its children are focused.\n     * @returns An observable that emits when the focus state of the element changes.\n     *     When the element is blurred, null will be emitted.\n     */\n    monitor(element: HTMLElement, checkChildren?: boolean): Observable<FocusOrigin>;\n\n    monitor(element: HTMLElement, renderer?: Renderer2 | boolean, checkChildren?: boolean): Observable<FocusOrigin> {\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof Renderer2)) {\n            checkChildren = renderer;\n        }\n\n        checkChildren = !!checkChildren;\n\n        if (!this._platform.isBrowser) { return observableOf(null); }\n\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            let cachedInfo = this._elementInfo.get(element);\n            cachedInfo!.checkChildren = checkChildren;\n            return cachedInfo!.subject.asObservable();\n        }\n\n        // Create monitored element info.\n        let info: MonitoredElementInfo = {\n            unlisten: () => {\n            },\n            checkChildren: checkChildren,\n            subject: new Subject<FocusOrigin>()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        let focusListener = (event: FocusEvent) => this._onFocus(event, element);\n        let blurListener = (event: FocusEvent) => this._onBlur(event, element);\n        this._ngZone.runOutsideAngular(() => {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n\n        // Create an unlisten function for later.\n        info.unlisten = () => {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n\n        return info.subject.asObservable();\n    }\n\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    stopMonitoring(element: HTMLElement): void {\n        const elementInfo = this._elementInfo.get(element);\n\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    }\n\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    focusVia(element: HTMLElement, origin: FocusOrigin): void {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    }\n\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n\n    /** Register necessary event listeners on the document and window. */\n    private _registerGlobalListeners() {\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) { return; }\n\n        // On keydown record the origin and clear any touch event that may be in progress.\n        let documentKeydownListener = () => {\n            this._lastTouchTarget = null;\n            this._setOriginForCurrentEventQueue('keyboard');\n        };\n\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        let documentMousedownListener = () => {\n            if (!this._lastTouchTarget) {\n                this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        let documentTouchstartListener = (event: TouchEvent) => {\n            if (this._touchTimeoutId != null) {\n                clearTimeout(this._touchTimeoutId);\n            }\n            this._lastTouchTarget = event.target;\n            this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n        };\n\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        let windowFocusListener = () => {\n            this._windowFocused = true;\n            this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false, 0);\n        };\n\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(() => {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener,\n                supportsPassiveEventListeners() ? ({ passive: true, capture: true } as any) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n\n        this._unregisterGlobalListeners = () => {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener,\n                supportsPassiveEventListeners() ? ({ passive: true, capture: true } as any) : true);\n            window.removeEventListener('focus', windowFocusListener);\n\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._touchTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        };\n    }\n\n    private _toggleClass(element: Element, className: string, shouldSet: boolean) {\n        if (shouldSet) {\n            element.classList.add(className);\n        } else {\n            element.classList.remove(className);\n        }\n    }\n\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    private _setClasses(element: HTMLElement, origin?: FocusOrigin): void {\n        const elementInfo = this._elementInfo.get(element);\n\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    }\n\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param origin The origin to set.\n     */\n    private _setOriginForCurrentEventQueue(origin: FocusOrigin): void {\n        this._origin = origin;\n        this._originTimeoutId = setTimeout(() => this._origin = null, 0);\n    }\n\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param event The focus event to check.\n     * @returns Whether the event was caused by a touch.\n     */\n    private _wasCausedByTouch(event: FocusEvent): boolean {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        let focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    }\n\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    private _onFocus(event: FocusEvent, element: HTMLElement) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            } else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            } else {\n                this._origin = 'program';\n            }\n        }\n\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    }\n\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event: FocusEvent, element: HTMLElement) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    }\n\n    private _incrementMonitoredElementCount() {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    }\n\n    private _decrementMonitoredElementCount() {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = () => {\n            };\n        }\n    }\n}\n\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\n@Directive({\n    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n})\nexport class CdkMonitorFocus implements OnDestroy {\n    private _monitorSubscription: Subscription;\n    @Output() cdkFocusChange = new EventEmitter<FocusOrigin>();\n\n    constructor(private _elementRef: ElementRef, private _focusMonitor: FocusMonitor) {\n        this._monitorSubscription = this._focusMonitor.monitor(\n            this._elementRef.nativeElement,\n            this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => this.cdkFocusChange.emit(origin));\n    }\n\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    }\n}\n\n/** @docs-private */\nexport function FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusMonitor, ngZone: NgZone, platform: Platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n\n/** @docs-private */\nexport const FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n"]}