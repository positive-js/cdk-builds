{"version":3,"file":"list-key-manager.js","sourceRoot":"","sources":["../../../../../src/cdk/a11y/key-manager/list-key-manager.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { QueryList } from '@angular/core';\n\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport {\n    UP_ARROW,\n    DOWN_ARROW,\n    LEFT_ARROW,\n    RIGHT_ARROW,\n    TAB,\n    A,\n    Z,\n    ZERO,\n    NINE\n} from '@ptsecurity/cdk/keycodes';\n\n\n// This interface is for items that can be passed to a ListKeyManager.\nexport interface IListKeyManagerOption {\n    // Whether the option is disabled.\n    disabled?: boolean;\n\n    // Gets the label for this option.\n    getLabel?(): string;\n}\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends IListKeyManagerOption> {\n    private _activeItemIndex = -1;\n    private _activeItem: T;\n    private _wrap = false;\n    private _letterKeyStream = new Subject<string>();\n    private _typeaheadSubscription = Subscription.EMPTY;\n    private _vertical = true;\n    private _horizontal: 'ltr' | 'rtl' | null;\n\n    // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n    private _pressedLetters: string[] = [];\n\n    constructor(private _items: QueryList<T>) {\n        _items.changes.subscribe((newItems: QueryList<T>) => {\n            if (this._activeItem) {\n                const itemArray = newItems.toArray();\n                const newIndex = itemArray.indexOf(this._activeItem);\n\n                if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                    this._activeItemIndex = newIndex;\n                }\n            }\n        });\n    }\n\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    tabOut: Subject<void> = new Subject<void>();\n\n    /** Stream that emits whenever the active item of the list manager changes. */\n    change = new Subject<number>();\n\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    withWrap(): this {\n        this._wrap = true;\n        return this;\n    }\n\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled: boolean = true): this {\n        this._vertical = enabled;\n\n        return this;\n    }\n\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n        this._horizontal = direction;\n\n        return this;\n    }\n\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval: number = 200): this {\n        if (this._items.length && this._items.some(item => typeof item.getLabel !== 'function')) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n\n        this._typeaheadSubscription.unsubscribe();\n\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(\n            tap((keyCode) => this._pressedLetters.push(keyCode)),\n            debounceTime(debounceInterval),\n            filter(() => this._pressedLetters.length > 0),\n            map(() => this._pressedLetters.join(''))\n        ).subscribe((inputString) => {\n            const items = this._items.toArray();\n\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n\n                if (!item.disabled && item.getLabel!().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n\n            this._pressedLetters = [];\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    setActiveItem(index: number): void {\n        const previousIndex = this._activeItemIndex;\n\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    }\n\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event: KeyboardEvent): void {\n        const keyCode = event.keyCode;\n\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n\n                return;\n\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                } else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                } else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n\n    // Index of the currently active item.\n    get activeItemIndex(): number | null {\n        return this._activeItemIndex;\n    }\n\n    // The active item.\n    get activeItem(): T | null {\n        return this._activeItem;\n    }\n\n    // Sets the active item to the first enabled item in the list.\n    setFirstItemActive(): void {\n        this._setActiveItemByIndex(0, 1);\n    }\n\n    // Sets the active item to the last enabled item in the list.\n    setLastItemActive(): void {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n\n    // Sets the active item to the next enabled item in the list.\n    setNextItemActive(): void {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n\n    // Sets the active item to a previous enabled item in the list.\n    setPreviousItemActive(): void {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    updateActiveItemIndex(index: number) {\n        this._activeItemIndex = index;\n    }\n\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    private _setActiveItemByDelta(delta: number, items = this._items.toArray()): void {\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    }\n\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    private _setActiveInWrapMode(delta: number, items: T[]): void {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        } else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    }\n\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    private _setActiveInDefaultMode(delta: number, items: T[]): void {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    }\n\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    private _setActiveItemByIndex(index: number, fallbackDelta: number, items = this._items.toArray()): void {\n        if (!items[index]) { return; }\n\n        while (items[index].disabled) {\n            index += fallbackDelta;\n\n            if (!items[index]) { return; }\n        }\n\n        this.setActiveItem(index);\n    }\n}\n"]}