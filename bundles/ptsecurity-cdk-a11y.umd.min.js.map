{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../packages/cdk/a11y/key-manager/list-key-manager.ts","../../../packages/cdk/a11y/key-manager/activedescendant-key-manager.ts","../../../packages/cdk/a11y/key-manager/focus-key-manager.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__spread","arguments","length","concat","ListKeyManager","_items","_this","tabOut","Subject","change","previousActiveItemIndex","_activeItemIndex","wrap","letterKeyStream","typeaheadSubscription","Subscription","EMPTY","vertical","scrollSize","pressedLetters","skipPredicateFn","item","disabled","QueryList","changes","subscribe","newItems","_activeItem","newIndex","toArray","indexOf","defineProperty","withScrollSize","withWrap","withVerticalOrientation","enabled","withHorizontalOrientation","direction","horizontal","withTypeAhead","debounceInterval","searchLetterIndex","some","getLabel","Error","unsubscribe","pipe","tap","keyCode","debounceTime","filter","map","join","inputString","items","index","toUpperCase","trim","setActiveItem","updateActiveItem","onKeydown","event","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","key","toLocaleUpperCase","A","Z","ZERO","NINE","fromCharCode","preventDefault","setFirstItemActive","setActiveItemByIndex","setLastItemActive","setActiveItemByDelta","setNextPageItemActive","delta","setPreviousPageItemActive","itemArray","setActiveInWrapMode","setActiveInDefaultMode","getItemsArray","fallbackDelta","curIndex","ActiveDescendantKeyManager","_super","activeItem","setInactiveStyles","setActiveStyles","FocusKeyManager","apply","origin","setFocusOrigin","focus"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { QueryList } from '@angular/core';\nimport {\n    UP_ARROW,\n    DOWN_ARROW,\n    LEFT_ARROW,\n    RIGHT_ARROW,\n    TAB,\n    A,\n    Z,\n    ZERO,\n    NINE\n} from '@ptsecurity/cdk/keycodes';\nimport { Subject, Subscription } from 'rxjs';\nimport { debounceTime, filter, map, tap } from 'rxjs/operators';\n\n\n// This interface is for items that can be passed to a ListKeyManager.\n// tslint:disable-next-line naming-convention\nexport interface ListKeyManagerOption {\n    // Whether the option is disabled.\n    disabled?: boolean;\n\n    // Gets the label for this option.\n    getLabel?(): string;\n}\n\n/* tslint:disable:member-ordering */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n    /**\n     * Stream that emits any time the TAB key is pressed, so components can react\n     * when focus is shifted off of the list.\n     */\n    tabOut: Subject<void> = new Subject<void>();\n\n    /** Stream that emits whenever the active item of the list manager changes. */\n    change = new Subject<number>();\n\n    previousActiveItemIndex = -1;\n\n    // Index of the currently active item.\n    get activeItemIndex(): number {\n        return this._activeItemIndex;\n    }\n\n    private _activeItemIndex = -1;\n\n    // The active item.\n    get activeItem(): T | null {\n        return this._activeItem;\n    }\n\n    private _activeItem: T;\n\n    private wrap: boolean = false;\n    private letterKeyStream = new Subject<string>();\n    private typeaheadSubscription = Subscription.EMPTY;\n    private vertical = true;\n    private horizontal: 'ltr' | 'rtl' | null;\n\n    private scrollSize: number = 0;\n\n    // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n    private pressedLetters: string[] = [];\n\n    constructor(private _items: QueryList<T>) {\n        if (_items instanceof QueryList) {\n\n            _items.changes.subscribe((newItems: QueryList<T>) => {\n\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n\n    withScrollSize(scrollSize: number): this {\n        this.scrollSize = scrollSize;\n\n        return this;\n    }\n\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n\n    withWrap(): this {\n        this.wrap = true;\n\n        return this;\n    }\n\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled: boolean = true): this {\n        this.vertical = enabled;\n\n        return this;\n    }\n\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n        this.horizontal = direction;\n\n        return this;\n    }\n\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param searchLetterIndex letter index for incremental search, if is -1 search is disabled\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval: number = 200, searchLetterIndex: number = 0): this {\n        if (this._items.length && this._items.some((item) => typeof item.getLabel !== 'function')) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n\n        this.typeaheadSubscription.unsubscribe();\n\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters and convert those\n        // letters back into a string. Afterwards find the first item that starts with that string and select it.\n        this.typeaheadSubscription = this.letterKeyStream.pipe(\n            tap((keyCode) => this.pressedLetters.push(keyCode)),\n            debounceTime(debounceInterval),\n            filter(() => this.pressedLetters.length > 0),\n            map(() => this.pressedLetters.join(''))\n        ).subscribe((inputString) => {\n            if (searchLetterIndex === -1) {\n                this.pressedLetters = [];\n\n                return;\n            }\n\n            const items = this._items.toArray();\n\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n\n                if (\n                    !item.disabled &&\n                    item.getLabel!().toUpperCase().trim().indexOf(inputString) === searchLetterIndex\n                ) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n\n            this.pressedLetters = [];\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active or item The item to be set as active.\n     */\n    setActiveItem(index: number | T): void;\n\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param item The index of the item to be set as active.\n     */\n    setActiveItem(item: any): void {\n        this.previousActiveItemIndex = this._activeItemIndex;\n\n        this.updateActiveItem(item);\n\n        if (this._activeItemIndex !== this.previousActiveItemIndex) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line: deprecation\n        const keyCode = event.keyCode;\n\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n\n                return;\n\n            case DOWN_ARROW:\n                if (this.vertical) {\n                    this.setNextItemActive();\n                    break;\n                } else {\n                    return;\n                }\n\n            case UP_ARROW:\n                if (this.vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                } else {\n                    return;\n                }\n\n            case RIGHT_ARROW:\n                if (this.horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                } else if (this.horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                } else {\n                    return;\n                }\n\n            case LEFT_ARROW:\n                if (this.horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                } else if (this.horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                } else {\n                    return;\n                }\n\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this.letterKeyStream.next(event.key.toLocaleUpperCase());\n                } else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this.letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n\n        this.pressedLetters = [];\n        event.preventDefault();\n    }\n\n    // Sets the active item to the first enabled item in the list.\n    setFirstItemActive(): void {\n        this.setActiveItemByIndex(0, 1);\n    }\n\n    // Sets the active item to the last enabled item in the list.\n    setLastItemActive(): void {\n        this.setActiveItemByIndex(this._items.length - 1, -1);\n    }\n\n    // Sets the active item to the next enabled item in the list.\n    setNextItemActive(): void {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this.setActiveItemByDelta(1);\n    }\n\n    // Sets the active item to a previous enabled item in the list.\n    setPreviousItemActive(): void {\n        this._activeItemIndex < 0 && this.wrap ? this.setLastItemActive()\n            : this.setActiveItemByDelta(-1);\n    }\n\n    setNextPageItemActive(delta: number = this.scrollSize): void {\n        const nextItemIndex = this._activeItemIndex + delta;\n\n        if (nextItemIndex >= this._items.length) {\n            this.setLastItemActive();\n        } else {\n            this.setActiveItemByDelta(delta);\n        }\n    }\n\n    setPreviousPageItemActive(delta: number = this.scrollSize): void {\n        const nextItemIndex = this._activeItemIndex - delta;\n\n        if (nextItemIndex <= 0) {\n            this.setFirstItemActive();\n        } else {\n            this.setActiveItemByDelta(-delta);\n        }\n    }\n\n    /**\n     * Allows setting the active without any other effects.\n     * @param index Index of the item to be set as active.\n     */\n    updateActiveItem(index: number): void;\n\n    /**\n     * Allows setting the active item without any other effects.\n     * @param item Item to be set as active or index Index of the item to be set as active..\n     */\n    // tslint:disable-next-line:unified-signatures\n    updateActiveItem(item: number | T): void;\n\n    updateActiveItem(item: any): void {\n        const itemArray = this._items.toArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n\n        this._activeItemIndex = index;\n        this._activeItem = itemArray[index];\n    }\n\n    /**\n     * Predicate function that can be used to check whether an item should be skipped\n     * by the key manager. By default, disabled items are skipped.\n     */\n    private skipPredicateFn = (item: T) => item.disabled;\n\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    private setActiveItemByDelta(delta: number): void {\n        this.wrap ? this.setActiveInWrapMode(delta) : this.setActiveInDefaultMode(delta);\n    }\n\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    private setActiveInWrapMode(delta: number): void {\n        const items = this.getItemsArray();\n\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            const item = items[index];\n\n            if (!this.skipPredicateFn(item)) {\n                this.setActiveItem(index);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    private setActiveInDefaultMode(delta: number): void {\n        this.setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    private setActiveItemByIndex(index: number, fallbackDelta: number): void {\n        const items = this.getItemsArray();\n\n        if (!items[index]) { return; }\n\n        let curIndex = index;\n        while (this.skipPredicateFn(items[curIndex])) {\n            curIndex += fallbackDelta;\n\n            if (!items[curIndex]) { return; }\n        }\n\n        this.setActiveItem(curIndex);\n    }\n\n    /** Returns the items as an array. */\n    private getItemsArray(): T[] {\n        return this._items instanceof QueryList ? this._items.toArray() : this._items;\n    }\n}\n\n/* tslint:enable:member-ordering */\n","\nimport { ListKeyManager, ListKeyManagerOption } from './list-key-manager';\n\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n */\n// tslint:disable-next-line naming-convention\nexport interface Highlightable extends ListKeyManagerOption {\n    // Applies the styles for an active item to this item.\n    setActiveStyles(): void;\n\n    // Applies the styles for an inactive item to this item.\n    setInactiveStyles(): void;\n}\n\nexport class ActiveDescendantKeyManager<T> extends ListKeyManager<Highlightable & T> {\n\n    /**\n     * Sets the active item to the item at the specified index and adds the\n     * active styles to the newly active item. Also removes active styles\n     * from the previously active item.\n     * @param index Index of the item to be set as active.\n     */\n    setActiveItem(index: number): void;\n\n    /**\n     * Sets the active item to the item to the specified one and adds the\n     * active styles to the it. Also removes active styles from the\n     * previously active item.\n     * @param item Item to be set as active.\n     */\n    setActiveItem(item: T): void;\n\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    setActiveItem(index: any): void {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n\n        super.setActiveItem(index);\n\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n","import { FocusOrigin } from '@angular/cdk/a11y';\n\nimport { ListKeyManager, ListKeyManagerOption } from './list-key-manager';\n\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n */\nexport interface IFocusableOption extends ListKeyManagerOption {\n    // Focuses the `FocusableOption`. */\n    focus(origin?: FocusOrigin): void;\n}\n\nexport class FocusKeyManager<T> extends ListKeyManager<IFocusableOption & T> {\n    private origin: FocusOrigin = 'program';\n\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin: FocusOrigin): this {\n        this.origin = origin;\n\n        return this;\n    }\n\n    /**\n     * Sets the active item or index to the item that is specified and focuses it.\n     * @param item Item to be set as active.\n     */\n    setActiveItem(item: number | T): void;\n\n    setActiveItem(item: any): void {\n        super.setActiveItem(item);\n\n        if (this.activeItem) {\n            this.activeItem.focus(this.origin);\n        }\n    }\n}\n"]}